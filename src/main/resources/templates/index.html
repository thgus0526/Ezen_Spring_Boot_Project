<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
      layout:decorate="~{layout}">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Weather App</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap.min.css}">
    <!-- sbb CSS -->
    <link rel="stylesheet" type="text/css" th:href="@{/style.css}">

</head>

<body>

<div class="container-fluid" layout:fragment="content">
    <div class="row text-center">
        <div class="col-md-9 map-wrapper">
            <div id="map"></div>
        </div>
        <div class="col-md-3" id="weather"></div>
    </div>
</div>

<script>
    // 위치 정보 요청 함수
    function getLocation() {
        // Geolocation API 지원 여부 확인
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(showPosition, showError);
        } else {
            document.getElementById("location").innerHTML =
                "Geolocation is not supported by this browser.";
        }
    }

    // 위치 정보를 성공적으로 받아온 경우 실행되는 함수
    function showPosition(position) {
        var latitude = position.coords.latitude;
        var longitude = position.coords.longitude;

        // 위치 정보를 HTML 요소에 표시
        var locationElement = document.getElementById("weather");
        locationfunc(latitude, longitude);
    }

    // 위치 정보를 받아오는 도중 오류가 발생한 경우 실행되는 함수
    function showError(error) {
        var locationElement = document.getElementById("location");
        switch (error.code) {
            case error.PERMISSION_DENIED:
                locationElement.innerHTML =
                    "User denied the request for Geolocation.";
                break;
            case error.POSITION_UNAVAILABLE:
                locationElement.innerHTML = "Location information is unavailable.";
                break;
            case error.TIMEOUT:
                locationElement.innerHTML =
                    "The request to get user location timed out.";
                break;
            case error.UNKNOWN_ERROR:
                locationElement.innerHTML = "An unknown error occurred.";
                break;
        }
        locationfunc(33.2541205, 126.560076);
    }

    // 페이지 로드 시 위치 정보 요청
    window.onload = getLocation;
</script>

<script
        type="text/javascript"
        src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=2f76b9ff5693043658660eb94f70830e"
></script>
<script>
    function mapXY(x, y) {
        var mapContainer = document.getElementById("map"), // 지도를 표시할 div
            mapOption = {
                center: new kakao.maps.LatLng(x, y), // 지도의 중심좌표
                level: 8, // 지도의 확대 레벨
            };

        var map = new kakao.maps.Map(mapContainer, mapOption); // 지도를 생성합니다

        // 마커가 표시될 위치입니다
        var markerPosition = new kakao.maps.LatLng(x, y);

        // 마커를 생성합니다
        var marker = new kakao.maps.Marker({
            position: markerPosition,
        });

        // 마커가 지도 위에 표시되도록 설정합니다
        marker.setMap(map);
    }
</script>

<!-- 소스출처 : http://www.kma.go.kr/weather/forecast/digital_forecast.jsp
내부에 있음 // 기상청에서 이걸 왜 공식적으로 공개하지 않을까? // // (사용
예) // var rs = dfs_xy_conv("toLL","60","127"); // console.log(rs.lat,
rs.lng); -->

<script language="javascript">


    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(successCallback, errorCallback);
    } else {
        console.log("Geolocation is not supported by this browser.");
    }

    function successCallback(position) {
        var latitude = position.coords.latitude;
        var longitude = position.coords.longitude;
        console.log("Latitude: " + latitude + ", Longitude: " + longitude);
    }

    function errorCallback(error) {
        console.log("Geolocation error: " + error.message);
    }


    //<!--
    //
    // LCC DFS 좌표변환을 위한 기초 자료
    //
    var RE = 6371.00877; // 지구 반경(km)
    var GRID = 5.0; // 격자 간격(km)
    var SLAT1 = 30.0; // 투영 위도1(degree)
    var SLAT2 = 60.0; // 투영 위도2(degree)
    var OLON = 126.0; // 기준점 경도(degree)
    var OLAT = 38.0; // 기준점 위도(degree)
    var XO = 43; // 기준점 X좌표(GRID)
    var YO = 136; // 기1준점 Y좌표(GRID)

    // LCC DFS 좌표변환 ( code : "toXY"(위경도->좌표, v1:위도, v2:경도), "toLL"(좌표->위경도,v1:x, v2:y) )
    function dfs_xy_conv(code, v1, v2) {
        var DEGRAD = Math.PI / 180.0;
        var RADDEG = 180.0 / Math.PI;

        var re = RE / GRID;
        var slat1 = SLAT1 * DEGRAD;
        var slat2 = SLAT2 * DEGRAD;
        var olon = OLON * DEGRAD;
        var olat = OLAT * DEGRAD;

        var sn =
            Math.tan(Math.PI * 0.25 + slat2 * 0.5) /
            Math.tan(Math.PI * 0.25 + slat1 * 0.5);
        sn = Math.log(Math.cos(slat1) / Math.cos(slat2)) / Math.log(sn);
        var sf = Math.tan(Math.PI * 0.25 + slat1 * 0.5);
        sf = (Math.pow(sf, sn) * Math.cos(slat1)) / sn;
        var ro = Math.tan(Math.PI * 0.25 + olat * 0.5);
        ro = (re * sf) / Math.pow(ro, sn);
        var rs = {};
        if (code == "toXY") {
            rs["lat"] = v1;
            rs["lng"] = v2;
            var ra = Math.tan(Math.PI * 0.25 + v1 * DEGRAD * 0.5);
            ra = (re * sf) / Math.pow(ra, sn);
            var theta = v2 * DEGRAD - olon;
            if (theta > Math.PI) theta -= 2.0 * Math.PI;
            if (theta < -Math.PI) theta += 2.0 * Math.PI;
            theta *= sn;
            rs["x"] = Math.floor(ra * Math.sin(theta) + XO + 0.5);
            rs["y"] = Math.floor(ro - ra * Math.cos(theta) + YO + 0.5);
        } else {
            rs["x"] = v1;
            rs["y"] = v2;
            var xn = v1 - XO;
            var yn = ro - v2 + YO;
            ra = Math.sqrt(xn * xn + yn * yn);
            if (sn < 0.0) -ra;
            var alat = Math.pow((re * sf) / ra, 1.0 / sn);
            alat = 2.0 * Math.atan(alat) - Math.PI * 0.5;

            if (Math.abs(xn) <= 0.0) {
                theta = 0.0;
            } else {
                if (Math.abs(yn) <= 0.0) {
                    theta = Math.PI * 0.5;
                    if (xn < 0.0) -theta;
                } else theta = Math.atan2(xn, yn);
            }
            var alon = theta / sn + olon;
            rs["lat"] = alat * RADDEG;
            rs["lng"] = alon * RADDEG;
        }
        return rs;
    }
    //-->
</script>

<script
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"
></script>
<script>
    function locationfunc(xxx, yyy) {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0"); // 1을 더한 후 두 자리 수로 맞춤
        const date = String(now.getDate()).padStart(2, "0");
        const hour = String(now.getHours()).padStart(2, "0");

        const formattedDate = `${year}${month}${date}`;

        var baseDate = formattedDate;
        if(hour < '06'){
            baseDate =  `${year}${month}${date-1}`;
        }

        console.log("locationfunc");
        var rs = dfs_xy_conv("toXY", xxx, yyy);

        const apiKey = "pT92G96xAGF0VK2U3O0kj%2BmVmHumwJTe08EgnL98rAQTQQxeaqyiD85Sx9nrgex5BOEZp81ZKdK3a1llX6TMfw%3D%3D"; // 여기에 자신의 OpenWeatherMap API 키를 입력하세요
        const url = `https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst?serviceKey=${apiKey}&pageNo=1&numOfRows=1000&dataType=JSON&base_date=${baseDate}&base_time=0500&nx=${rs.x}&ny=${rs.y}`;
        fetch(url)
            .then((response) => response.json())
            .then((data) => {
                // 필요한 데이터 추출
                console.log(data);
                const items = data.response.body.items.item;

                // fcstTime의 데이터 필터링
                const filteredItems = items.filter(item => item.fcstDate === formattedDate)
                                                .filter(item => item.fcstTime.substring(0, 2) === hour);

                console.log("filteredItems:", filteredItems);

                // 필요한 카테고리 데이터 추출
                const popData = filteredItems.find(item => item.category === 'POP');
                const skyData = filteredItems.find(item => item.category === 'SKY');
                const tmpData = filteredItems.find(item => item.category === 'TMP');
                const ptyData = filteredItems.find(item => item.category === 'PTY');

                // 강수 형태에 따라 문자열 결정
                var ptyString = "";
                var ptyImg = "";
                if (ptyData) {
                    if (ptyData.fcstValue === "0") {
                        if (skyData.fcstValue === "1") {
                            ptyString = "맑음";
                            ptyImg = "sun.png";
                        }
                        else if (skyData.fcstValue === "3") {
                            ptyString = "구름많음";
                            ptyImg = "manyCloud.png";
                        }
                        else if (skyData.fcstValue === "4") {
                            ptyString = "흐림";
                            ptyImg = "cloud.png";
                        }
                    } else if (ptyData.fcstValue === "1") {
                        ptyString = "비";
                        ptyImg = "rain.png";
                    }
                    else if (ptyData.fcstValue === "2") {
                        ptyString = "비/눈";
                        ptyImg = "rainSnow.png";
                    }
                    else if (ptyData.fcstValue === "3") {
                        ptyString = "눈";
                        ptyImg = "snow.png";
                    }
                    else if (ptyData.fcstValue === "5") {
                        ptyString = "빗방울";
                        ptyImg = "littleRain.png";
                    }
                    else if (ptyData.fcstValue === "6") {
                        ptyString = "빗방울눈날림";
                        ptyImg = "littleRainSnow.png";
                    }
                    else if (ptyData.fcstValue === "7") {
                        ptyString = "눈날림";
                        ptyImg = "littleSnow.png";
                    }
                }

                const weather = document.getElementById("weather");

                const parseDate = `${year}년 ${month}월 ${date}일`;
                weather.innerHTML = `
                <img class="weatherIcon" src="./img/${ptyImg}" alt="날씨이미지" />
              <p>${parseDate}</p>
              <p>온도: ${tmpData.fcstValue}</p>
              <p>강수확률: ${popData.fcstValue}</p>
                    <p>하늘상태: ${skyData.fcstValue}</p>
                    <p>결과 : ${ptyString}</p>
              <p>${hour}시 기준 </p>
          `;
                mapXY(xxx, yyy);
            })
            .catch((error) =>
                console.error("Error fetching weather data:", error)
            );
    }
</script>


</body>
</html>
